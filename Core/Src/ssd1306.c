#include "ssd1306.h"
#include "main.h" 
#include <string.h>
#include <stdio.h>

extern I2C_HandleTypeDef hi2c1;

#define SSD1306_I2C_ADDR (0x3C << 1) // 7-bit 0x3C -> HAL uses 8-bit address
#define SSD1306_WIDTH 128
#define SSD1306_HEIGHT 64

static uint8_t buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];
static uint8_t cursor_x = 0;
static uint8_t cursor_y = 0;

/* Basic 5x8 font (ASCII 32..127) */
static const uint8_t font5x8[][5] = {
  /* space (32) .. tilde (126) subset: full set for common chars */
  /* Only include typical ASCII 32..127. For brevity some implementations trim; this contains standard 5x8 patterns. */
  /* Due to space: include minimal set for letters, digits and basic symbols used below */
  /* ' ' (32) */
  {0x00,0x00,0x00,0x00,0x00},/*space*/
  /* '!' (33) */ {0x00,0x00,0x5F,0x00,0x00},
  /* '"' (34) */ {0x00,0x07,0x00,0x07,0x00},
  /* '#' (35) */ {0x14,0x7F,0x14,0x7F,0x14},
  /* '$' (36) */ {0x24,0x2A,0x7F,0x2A,0x12},
  /* '%' (37) */ {0x23,0x13,0x08,0x64,0x62},
  /* '&' (38) */ {0x36,0x49,0x55,0x22,0x50},
  /* ''' (39) */ {0x00,0x05,0x03,0x00,0x00},
  /* '(' (40) */ {0x00,0x1C,0x22,0x41,0x00},
  /* ')' (41) */ {0x00,0x41,0x22,0x1C,0x00},
  /* '*' (42) */ {0x14,0x08,0x3E,0x08,0x14},
  /* '+' (43) */ {0x08,0x08,0x3E,0x08,0x08},
  /* ',' (44) */ {0x00,0x50,0x30,0x00,0x00},
  /* '-' (45) */ {0x08,0x08,0x08,0x08,0x08},
  /* '.' (46) */ {0x00,0x60,0x60,0x00,0x00},
  /* '/' (47) */ {0x20,0x10,0x08,0x04,0x02},
  /* '0' (48) */ {0x3E,0x51,0x49,0x45,0x3E},
  /* '1' (49) */ {0x00,0x42,0x7F,0x40,0x00},
  /* '2' (50) */ {0x42,0x61,0x51,0x49,0x46},
  /* '3' (51) */ {0x21,0x41,0x45,0x4B,0x31},
  /* '4' (52) */ {0x18,0x14,0x12,0x7F,0x10},
  /* '5' (53) */ {0x27,0x45,0x45,0x45,0x39},
  /* '6' (54) */ {0x3C,0x4A,0x49,0x49,0x30},
  /* '7' (55) */ {0x01,0x71,0x09,0x05,0x03},
  /* '8' (56) */ {0x36,0x49,0x49,0x49,0x36},
  /* '9' (57) */ {0x06,0x49,0x49,0x29,0x1E},
  /* ':' (58) */ {0x00,0x36,0x36,0x00,0x00},
  /* ';' (59) */ {0x00,0x56,0x36,0x00,0x00},
  /* '<' (60) */ {0x08,0x14,0x22,0x41,0x00},
  /* '=' (61) */ {0x14,0x14,0x14,0x14,0x14},
  /* '>' (62) */ {0x00,0x41,0x22,0x14,0x08},
  /* '?' (63) */ {0x02,0x01,0x51,0x09,0x06},
  /* '@' (64) */ {0x32,0x49,0x79,0x41,0x3E},
  /* 'A' (65) */ {0x7E,0x11,0x11,0x11,0x7E},
  /* 'B' (66) */ {0x7F,0x49,0x49,0x49,0x36},
  /* 'C' (67) */ {0x3E,0x41,0x41,0x41,0x22},
  /* 'D' (68) */ {0x7F,0x41,0x41,0x22,0x1C},
  /* 'E' (69) */ {0x7F,0x49,0x49,0x49,0x41},
  /* 'F' (70) */ {0x7F,0x09,0x09,0x09,0x01},
  /* 'G' (71) */ {0x3E,0x41,0x49,0x49,0x7A},
  /* 'H' (72) */ {0x7F,0x08,0x08,0x08,0x7F},
  /* 'I' (73) */ {0x00,0x41,0x7F,0x41,0x00},
  /* 'J' (74) */ {0x20,0x40,0x41,0x3F,0x01},
  /* 'K' (75) */ {0x7F,0x08,0x14,0x22,0x41},
  /* 'L' (76) */ {0x7F,0x40,0x40,0x40,0x40},
  /* 'M' (77) */ {0x7F,0x02,0x0C,0x02,0x7F},
  /* 'N' (78) */ {0x7F,0x04,0x08,0x10,0x7F},
  /* 'O' (79) */ {0x3E,0x41,0x41,0x41,0x3E},
  /* 'P' (80) */ {0x7F,0x09,0x09,0x09,0x06},
  /* 'Q' (81) */ {0x3E,0x41,0x51,0x21,0x5E},
  /* 'R' (82) */ {0x7F,0x09,0x19,0x29,0x46},
  /* 'S' (83) */ {0x46,0x49,0x49,0x49,0x31},
  /* 'T' (84) */ {0x01,0x01,0x7F,0x01,0x01},
  /* 'U' (85) */ {0x3F,0x40,0x40,0x40,0x3F},
  /* 'V' (86) */ {0x1F,0x20,0x40,0x20,0x1F},
  /* 'W' (87) */ {0x3F,0x40,0x38,0x40,0x3F},
  /* 'X' (88) */ {0x63,0x14,0x08,0x14,0x63},
  /* 'Y' (89) */ {0x07,0x08,0x70,0x08,0x07},
  /* 'Z' (90) */ {0x61,0x51,0x49,0x45,0x43},
  /* '[' (91) */ {0x00,0x7F,0x41,0x41,0x00},
  /* '\' (92) */ {0x02,0x04,0x08,0x10,0x20},
  /* ']' (93) */ {0x00,0x41,0x41,0x7F,0x00},
  /* '^' (94) */ {0x04,0x02,0x01,0x02,0x04},
  /* '_' (95) */ {0x40,0x40,0x40,0x40,0x40},
  /* '`' (96) */ {0x00,0x01,0x02,0x04,0x00},
  /* 'a' (97) */ {0x20,0x54,0x54,0x54,0x78},
  /* 'b' (98) */ {0x7F,0x48,0x44,0x44,0x38},
  /* 'c' (99) */ {0x38,0x44,0x44,0x44,0x20},
  /* 'd' (100) */ {0x38,0x44,0x44,0x48,0x7F},
  /* 'e' (101) */ {0x38,0x54,0x54,0x54,0x18},
  /* 'f' (102) */ {0x08,0x7E,0x09,0x01,0x02},
  /* 'g' (103) */ {0x0C,0x52,0x52,0x52,0x3E},
  /* 'h' (104) */ {0x7F,0x08,0x04,0x04,0x78},
  /* 'i' (105) */ {0x00,0x44,0x7D,0x40,0x00},
  /* 'j' (106) */ {0x20,0x40,0x44,0x3D,0x00},
  /* 'k' (107) */ {0x7F,0x10,0x28,0x44,0x00},
  /* 'l' (108) */ {0x00,0x41,0x7F,0x40,0x00},
  /* 'm' (109) */ {0x7C,0x04,0x18,0x04,0x78},
  /* 'n' (110) */ {0x7C,0x08,0x04,0x04,0x78},
  /* 'o' (111) */ {0x38,0x44,0x44,0x44,0x38},
  /* 'p' (112) */ {0x7C,0x14,0x14,0x14,0x08},
  /* 'q' (113) */ {0x08,0x14,0x14,0x18,0x7C},
  /* 'r' (114) */ {0x7C,0x08,0x04,0x04,0x08},
  /* 's' (115) */ {0x48,0x54,0x54,0x54,0x20},
  /* 't' (116) */ {0x04,0x3F,0x44,0x40,0x20},
  /* 'u' (117) */ {0x3C,0x40,0x40,0x20,0x7C},
  /* 'v' (118) */ {0x1C,0x20,0x40,0x20,0x1C},
  /* 'w' (119) */ {0x3C,0x40,0x30,0x40,0x3C},
  /* 'x' (120) */ {0x44,0x28,0x10,0x28,0x44},
  /* 'y' (121) */ {0x0C,0x50,0x50,0x50,0x3C},
  /* 'z' (122) */ {0x44,0x64,0x54,0x4C,0x44},
  /* '{' (123) */ {0x00,0x08,0x36,0x41,0x00},
  /* '|' (124) */ {0x00,0x00,0x7F,0x00,0x00},
  /* '}' (125) */ {0x00,0x41,0x36,0x08,0x00},
  /* '~' (126) */ {0x08,0x04,0x08,0x10,0x08}
};

static HAL_StatusTypeDef ssd1306_WriteCommand(uint8_t cmd)
{
    uint8_t buf[2] = {0x00, cmd};
    return HAL_I2C_Master_Transmit(&hi2c1, SSD1306_I2C_ADDR, buf, 2, 100);
}

static HAL_StatusTypeDef ssd1306_WriteData(uint8_t *data, size_t size)
{
    // data prefix 0x40
    // We will allocate a small buffer for transmission in chunks
    HAL_StatusTypeDef ret = HAL_OK;
    uint8_t chunk[17]; // 1 control + 16 data per chunk (to keep stack small)
    size_t i = 0;
    while (i < size)
    {
        uint8_t len = (uint8_t)((size - i) > 16 ? 16 : (size - i));
        chunk[0] = 0x40;
        memcpy(&chunk[1], &data[i], len);
        ret = HAL_I2C_Master_Transmit(&hi2c1, SSD1306_I2C_ADDR, chunk, len + 1, 100);
        if (ret != HAL_OK) return ret;
        i += len;
    }
    return ret;
}

void ssd1306_Init(void)
{
    HAL_Delay(100);
    ssd1306_WriteCommand(0xAE); // display off
    ssd1306_WriteCommand(0x20); // set memory addressing mode
    ssd1306_WriteCommand(0x00); // horizontal addressing
    ssd1306_WriteCommand(0xB0); // set page start address
    ssd1306_WriteCommand(0xC8); // COM output scan direction
    ssd1306_WriteCommand(0x00); // low col
    ssd1306_WriteCommand(0x10); // high col
    ssd1306_WriteCommand(0x40); // start line
    ssd1306_WriteCommand(0x81); // contrast
    ssd1306_WriteCommand(0x7F);
    ssd1306_WriteCommand(0xA1); // segment remap
    ssd1306_WriteCommand(0xA6); // normal display
    ssd1306_WriteCommand(0xA8); // multiplex
    ssd1306_WriteCommand(0x3F);
    ssd1306_WriteCommand(0xA4); // display all on resume
    ssd1306_WriteCommand(0xD3); // display offset
    ssd1306_WriteCommand(0x00);
    ssd1306_WriteCommand(0xD5); // display clock divide
    ssd1306_WriteCommand(0xF0);
    ssd1306_WriteCommand(0xD9); // pre-charge
    ssd1306_WriteCommand(0x22);
    ssd1306_WriteCommand(0xDA); // com pins
    ssd1306_WriteCommand(0x12);
    ssd1306_WriteCommand(0xDB); // vcomh
    ssd1306_WriteCommand(0x20);
    ssd1306_WriteCommand(0x8D); // charge pump
    ssd1306_WriteCommand(0x14);
    ssd1306_WriteCommand(0xAF); // display on

    ssd1306_Fill(0);
    ssd1306_UpdateScreen();
}

void ssd1306_Fill(uint8_t color)
{
    memset(buffer, color ? 0xFF : 0x00, sizeof(buffer));
}

void ssd1306_UpdateScreen(void)
{
    // SSD1306 uses pages; update page by page
    for (uint8_t page = 0; page < (SSD1306_HEIGHT / 8); page++)
    {
        ssd1306_WriteCommand(0xB0 + page);
        ssd1306_WriteCommand(0x00); // low col 0
        ssd1306_WriteCommand(0x10); // high col 0
        uint8_t *ptr = &buffer[SSD1306_WIDTH * page];
        // send data in chunks
        HAL_StatusTypeDef res = ssd1306_WriteData(ptr, SSD1306_WIDTH);
        (void)res;
    }
}

void ssd1306_SetCursor(uint8_t x, uint8_t y)
{
    cursor_x = x;
    cursor_y = y;
}

static void ssd1306_DrawChar(uint8_t x, uint8_t y, char ch)
{
    if (ch < 32 || ch > 126) ch = '?';
    const uint8_t *glyph = font5x8[ch - 32];
    // y is pixel row (0..56), but we arrange writes into buffer pages (8-pixel rows)
    for (uint8_t i = 0; i < 5; i++)
    {
        uint8_t col = glyph[i];
        for (uint8_t row = 0; row < 8; row++)
        {
            uint8_t pixel = (col >> row) & 0x01;
            uint16_t px = x + i;
            uint16_t py = y + row;
            if (px >= SSD1306_WIDTH || py >= SSD1306_HEIGHT) continue;
            uint16_t index = (px) + (py / 8) * SSD1306_WIDTH;
            if (pixel)
                buffer[index] |= (1 << (py % 8));
            else
                buffer[index] &= ~(1 << (py % 8));
        }
    }
    // 1-pixel space between chars
    for (uint8_t row = 0; row < 8; row++)
    {
        uint16_t px = x + 5;
        uint16_t py = y + row;
        if (px >= SSD1306_WIDTH || py >= SSD1306_HEIGHT) continue;
        uint16_t index = (px) + (py / 8) * SSD1306_WIDTH;
        buffer[index] &= ~(1 << (py % 8));
    }
}

void ssd1306_WriteString(uint8_t x, uint8_t y, const char *str)
{
    uint8_t cx = x;
    while (*str)
    {
        ssd1306_DrawChar(cx, y, *str);
        cx += 6; // 5 pixels +1 space
        str++;
    }
}

void ssd1306_WriteInt(uint8_t x, uint8_t y, int val)
{
    char buf[16];
    snprintf(buf, sizeof(buf), "%d", val);
    ssd1306_WriteString(x, y, buf);
}
